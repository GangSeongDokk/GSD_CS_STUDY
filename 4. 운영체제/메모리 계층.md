# 메모리 계층

메모리 계층은 레지스터, 캐시, 메모리, 저장장치로 구성되어 있다.

|계층|휘발성|속도|용량|
|-|-|-|-|
|레지스터(CPU 내부 메모리)|O|매우 빠름|매우 적음|
|캐시(L1, L2 캐시)|O|빠름|적음|
|메모리(주기억장치)|O|보통|보통|
|보조기억장치(SSD, HDD)|X|느림|많음|

계층이 위로 올라갈 수록 가격은 비싸지며, 용량은 작아지고 속도는 빨라진다.

더 많은 용량을 더 싸게 확보하기 위해서 계층을 나누어 관리하며 필요시마다 데이터를 하위 계층으로부터 로딩하여 상위계층으로 적재하는 과정을 거친다.

# 캐시

캐시는 데이터를 미리 복사해놓는 임시 저장소이자 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리를 의미한다.

이를 통해 데이터에 접근하는 시간을 줄이고, 상위 계층에서 다 저장하지 못하는 연산 결과 데이터를 나누어 저장함으로써 처리 속도를 향상시킬 수 있다.

RAM과 CPU 사이의 속도 차이가 너무 크기 때문에 그 사이에 레지스터 계층을 두어서 속도 차이로 인한 병목을 감소시키는데, 이렇게 속도 차이가 나는 계층들 사이에 두어 속도 문제를 해결하기 위한 계층을 캐싱 계층이라고 한다.

캐시 메모리와 보조기억장치 사이에 있는 주기억장치를 보조기억장치의 캐싱계층이라고 할 수 있다.

# 지역성의 원리

캐시 계층을 두지 않고 캐시를 직접 설정해야한다면, 자주 사용하는 데이터를 기반으로 설정해야 할 것이다.

그 기준이 되는 것이 지역성이며, 지역성에는 시간 지역성(temporal locality)과 공간 지역성(spatial locality)이 존재한다.

## 시간 지역성

데이터 읽기/쓰기를 위해 최근 사용했던 메모리 공간은 가까운 시간 내에 다시 사용될 가능성이 높다는 것을 의미한다.

for문에서 i를 매개변수로 사용했다면, 이 데이터에 반복적으로 재접근을 해야할 것인데 이러한 경향을 시간 지역성이라고 한다.

## 공간 지역성

특정 데이터를 사용했다면, 그 주변의 메모리 공간의 데이터 역시 사용될 가능성이 높다는 것을 의미한다.

따라서 어떤 데이터를 사용하기 위해 캐시로 로드한다면, 그 데이터뿐만 아니라 그 주변 블록들까지 한꺼번에 캐시로 로드하여 캐시히트될 확률을 높힐 수 있다.

[공간지역성](./공간지역성.py)

메모리에 연속으로 접근할 수 있을때와 그렇지 않을때의 성능 차이를 위 코드에서 확인할 수 있다.

# 캐시히트와 캐시미스

원하는 데이터가 캐시에 있다면 캐시히트라고 하며, 원하는 데이터가 캐시에 없을 경우 주 메모리로 가서 그 데이터를 찾아오는데 이것을 캐시미스라고 한다.

![image](https://github.com/GangSeongDokk/GSD_CS_STUDY/assets/109258608/a13fb7fe-6769-40a5-95b5-99bb9a2fd670)

캐시히트를 하게 되면 해당 데이터를 제어장치를 거쳐 가져오게 된다.

캐시히트의 경우 위치도 가깝고 CPU 내부 버스를 기반으로 작동하기 때문에 빠르지만, 캐시미스의 경우 시스템 버스를 기반으로 메모리의 데이터를 로드하게 되므로 느리다.

## 캐시매핑

캐시가 히트되기 위해 매핑하는 방법이다.

CPU 레지스터와 주메모리(RAM)간에 데이터를 주고 받을 때, 레지스터는 주메모리에 비하면 매우 작기에 매핑이 잘 되어있어야 캐시 계층의 역할을 잘 수행할 수 있다.

|방식|설명|
|-|-|
|직접 매핑(directed mapping)|메모리가 1~1000이 있고, 캐시가 1~10이라면 캐시의 1을 메모리의 1~100에, 2를 101~200에 매핑하는 방법. 구현이 간단하지만, 캐시가 효율적이지 않고 캐시교체가 잦다.|
|연관 매핑(associative mapping)|필요한 메모리값을 캐시의 원하는 곳에 자유롭게 저장한다. 인덱싱되어 있지 않기에 찾는과정이 복잡하고 느리지만, 캐시히트 가능성이 높아진다.|
|집합 연관 매핑(set associative mapping)|직접 매핑과 연관 매핑을 합쳐놓은 것. 순서를 일치시키지만, 그룹을 구성하여 블록화한다. 1~1000의 메모리와 1~10의 캐시가 있다면, 캐시의 1~5를 블록화하여 메모리의 1~500중 원하는 데이터를 자유롭게 저장한다. 검색이 더 효율적이며, 캐시히트 가능성이 상당히 높다.|


# 웹 브라우저의 캐시

대표적인 캐시로는 웹 브라우저에서도 찾을 수 있는데, 쿠키, 로컬 스토리지, 세션 스토리지가 있다.

이러한 것들은 보통 사용자의 커스텀 정보나 인증 모듈 관련 사항들을 웹 브라우저에 저장해서 추후 서버에 요청을 보낼 때, 자신을 나타내는 아이덴티티나 중복 요청 방지를 위해 쓰인다.

## 쿠키

쿠키는 만료 기한이 있는 키-값 저장소이며, 4KB까지 데이터를 저장할 수 있고 만료기한도 정할 수 있는데 대부분 서버에서 만료기간을 정한다.

same site 옵션을 strict로 설정하지 않았을 경우 다른 도메인에서 요청했을때 자동 전송된다.

쿠키를 설정했을때는 document.cookie를 써서 쿠키를 보는 것이 불가능하도록 httponly 옵션을 걸어야한다.

## 로컬 스토리지

로컬 스토리지는 만료기한이 없는 키-값 저장소이다. 10MB까지 저장할 수 있고, 웹 브라우저를 닫아도 유지되며 도메인 단위로 저장되고 생성된다.

HTML5를 지원하지 않는 웹 브라우저에서는 사용할 수 없으며, 클라이언트에서만 수정 가능하다.

## 세션 스토리지

세션 스토리지는 만료기간이 없는 키-값 저장소이다. 탭 단위로 세션 스토리지를 생성하며, 5MB까지 저장이 가능하고 탭을 닫을때 해당 데이터가 삭제된다.

HTML5를 지원하지 않는 웹 브라우저에서는 사용할 수 없으며, 클라이언트에서만 수정 가능하다.

# 데이터 베이스의 캐싱 계층

데이터 베이스 시스템을 구성할때도 메인 데이터베이스 위에 레디스 데이터 베이스 계층을 캐싱 계층으로 둬서 성능을 향상시키기도 한다.

# 캐시 전략

데이터베이스에서 캐시를 사용하게 되면 반드시 데이터 정합성 문제가 따라오게 된다.

데이터 정합성 문제란, 같은 데이터임에도 불구하고 캐시 계층과 데이터베이스 계층에서 다른 데이터값이 저장되어 있는 현상을 말한다.

적절한 캐시 읽기 전략과 쓰기 전략을 통해 캐시와 데이터베이스간의 데이터 정합성 문제를 해결하면서도 성능을 잃지 않도록 해야한다.

# 캐시 읽기 전략

## Look Aside 패턴

- 캐시히트 : 캐시에서 데이터를 가져온다.
- 캐시미스 : 데이터베이스에서 데이터를 조회하고, 캐시에도 업데이트한다.

cash aside 패턴이라고도 불린다.

데이터를 찾을때, 캐시에 데이터가 있는지 우선 확인하고 캐시에 데이터가 없다면 데이터 베이스를 검색한다.

반복적인 읽기가 많이 발생할때 효율적이며, 캐시와 데이터베이스가 분리되어있으므로 캐시가 일시적으로 장애를 일으켜도 데이터 베이스에서 데이터를 조회할 수 있다.

그러나 만약 캐시가 많은 조회를 처리하고 있었다면, 캐시가 다운되었을때 상대적으로 속도가 느린 데이터베이스에 많은 조회요청이 몰려 높은 부하를 줄 수 있다.

## Read Through 패턴

- 캐시히트 : 캐시에서 데이터를 가져온다.
- 캐시미스 : 캐시가 데이터베이스를 조회하여 자체적으로 데이터를 업데이트한다. 다시 캐시에서 데이터를 가져온다.

캐시에서만 데이터를 읽어오는 전략이다.

데이터의 동기화를 캐시 제공자에게 위임하는 방식으로 속도가 좀 느려지며, 전적으로 캐시 제공자에게 데이터 조회를 의존하므로 캐시 제공자가 장애를 일으킬 경우 서비스에 크게 영향을 미친다.

그러나 캐시와 데이터베이스가 항상 동기화되므로 데이터 정합성 문제가 해결된다.

# 캐시 쓰기 전략

## Write Back 패턴

Write Behind 패턴이라고도 불린다.

데이터를 저장할때 데이터베이스에 바로 쿼리하여 저장하지 않고, 캐시에 모았다가 일정 주기마다 배치작업을 통해 데이터베이스에 반영한다.

쓰기 쿼리의 비용과 부하를 줄일 수 있고 데이터 정합성을 확보할 수 있지만, 캐시 제공자가 장애를 일으키거나 다운될 경우 데이터가 완전히 소실될 우려가 있다.

쓰기가 자주 일어나면서도, 읽기에 많은 자원을 소모하는 서비스에 적합하다.

## Write Through 패턴

데이터 베이스와 캐시에 동시에 데이터를 저장하는 전략으로, 먼저 캐시에 저장한 뒤 바로 데이터 베이스에 이를 반영한다.

데이터베이스 동기화 작업을 캐시 제공자에게 완전히 위임하는 방식으로, 캐시와 데이터베이스가 항상 최신 상태로 유지되어 데이터 정합성을 확보할 수 있다.

데이터 유실이 발생하면 안되는 서비스에 적합하지만, 불필요한 쓰기를 반복하게 되므로 빈번한 생성 및 수정이 반복되는 경우에는 성능에 영향을 줄 수 있다.