# 3.3 프로세스와 스레드

## 프로세스와 스레드의 개념

### 프로세스(Process)

- 프로그램이 운영체제에 의해 `메모리 영역을 할당받(인스턴스화)고` 실행중인 상태
- 운영체제의 CPU 스케줄러에 따라 프로세스가 실행됨
- CPU 스케줄링의 대상이 되는 작업(task)라는 용어와 같은 의미로 쓰임

### 스레드(Thread)

- `한 Process 내에서 실행되는 여러 흐름의 단위`
- 프로세스가 할당받은 자원을 이용하는 실행의 단위

## 3.3.1 프로세스와 컴파일 과정(C언어 기준)

![image](https://t1.daumcdn.net/cfile/tistory/9901E4385C2880FA2E)

- 컴파일러가 `컴파일 과정`을 통해 `코드를 컴퓨터가 이해할 수 있는 기계어로 번역`하여 `실행할 수 있는 파일`을 만드는 과정

### 전처리

- 전처리기 구문('#'으로 시작하는 부분)을 만나면 헤더파일을 찾아서 그 내용을 순차적으로 삽입
- '#define', '#ifdef'와 같은 전처리기는 매크로 치환(구문을 처리)
- 소스코드의 주석을 제거

### 컴파일

- C언어 코드가 어셈블리어로 변환되는 과정
- 오류 처리 및 코드 최적화

### 어셈블

- 어셈블리어가 기계어로 변환되는 과정
- binary 파일인 object파일(.o)생성

### 링크

- 오브젝트 파일들과 프로그램 내에 있는 표준 라이브러리, 사용자 라이브러리를 결합하여 최종적으로 `실행파일(.exe)`를 생성

## 정적 라이브러리 vs 동적 라이브러리

### 정적 라이브러리(.lib)

- 실행 파일(프로그램)에 라이브러리의 내용이 포함되는 형식
- 라이브러리에 대한 추가적인 파일이 없어도 프로그램 실행이 가능
- 프로그램 실행 후 처리시간이 빠름
- 실행 파일의 크기가 커지는 단점이 있음

### 동적 라이브러리(.dll)

- 실행 파일안에 포함되지 않고, 프로그램 실행 시에 외부의 .dll파일에서 참조되는 형식
- 프로그램 실행 시 로딩 시간이 단축됨
- 여러 프로그램들이 메모리상에서 같은 DLL을 공유하여 사용할 수 있음

## 3.3.2 프로세스의 상태

![image](https://1.bp.blogspot.com/-gZJ31Dgw7bs/T5Z9SjzJiFI/AAAAAAAAJEk/S81m6yeBZqw/s1600/%EC%82%AC%EC%9A%A9%EC%9E%90+%EC%A7%80%EC%A0%95+10.jpg)

> ### 생성 상태(Created)
>
> - 프로세스가 생성됨. 사용자가 요청한 작업이 커널에 등록되고 PCB가 할당된 상태.
> - 생성(Created) -> 준비(Ready) : 메모리 공간을 검사하여 충분한 공간이 있으면 메모리를 할당하고 준비 상태로 바뀜
> - 생성(Created) -> 보류 준비(Suspended Ready) : 메모리 공간이 없으면 메모리를 할당하지 않고 보류 준비 상태로 바뀜
>
> ### 준비 상태(Ready)
>
> - CPU를 할당 받기 위해 기다리고 있는 상태. CPU 스케줄러부터 CPU 소유권이 넘어오면 바로 실행할 준비가 되어있음
> - 준비(Ready) -> 실행(Running) : `Dispatch`, CPU를 할당받아 실행상태로 바뀌고 프로세스가 실행됨
> - 준비(Ready) -> 보류 준비(Suspended Ready) : 메모리를 다시 빼앗긴 상태
>
> ### 실행 상태(Running)
>
> - CPU 소유권과 메모리를 할당받아 실행 중인 상태
> - 실행(Running) -> 준비(Ready) : `Timeout`, 실행되던 중 시간 할당량을 소진하여 메모리를 뺏긴 상태
> - 실행(Running) -> 대기(Blocked) : 실행 상태의 프로세스가 입출력이 필요하게 되어 시스템을 호출하고, 입출력 처리를 기다리는 상태. 이 때 CPU는 준비 상태인 프로세스들 중 하나를 선택하여 실행한다.
>
> ### 대기(Blocked)
>
> - 프로세스가 실행되다가 이벤트(인터럽트)가 발생되어 차단된 상태
> - 대기(Blocked) -> 준비(Ready) : 입출력 처리가 완료되어 CPU 할당을 기다리는 상태
> - 대기(Blocked) -> 보류 대기(Suspended Blocked) : 메모리 확보를 위해 대기 상태에서 메모리를 빼앗긴 상태
>
> ### 종료(Terminated)
>
> - 메모리와 CPU 소유권을 모두 반납하고 프로세스가 종료됨

## 3.3.3 프로세스의 메모리 구조

### 스택(Stack) 영역

- 프로그램 동작 시(런타임 단계)에 크기가 결정
- 함수 호출과 관계되는 `지역변수, 매개변수가 저장`됨
- 함수 호출 시 생성되며, 함수가 끝나면 반환
- 높은 주소부터 할당됨

### 힙(Heap)영역

- 메모리 주소 값에 의해서만 참조되고 사용되는 영역으로, 프로그램 동작 시(런타임)에 크기가 결정
- 낮은 주소부터 할당됨

### 데이터 영역

- `전역 변수(global variable)와 정적 변수(static variable)가 저장되는 영역`으로, 프로그램이 시작 될 때(컴파일 단계)에 메모리에 할당됨
- BSS(Block Stated Symbol) 영역 : global, static, const로 선언은 되어있지만 초기화 되지않은 변수들이 할당되는 메모리 영역 -> 자동으로 초기화 해줌
- Data 영역 : 초기값을 설정한 변수가 할당되는 영역

### 코드 영역

- 실행할 프로그램의 코드가 저장됨

## PCB(Process Control Block)

### PCB란?

- 프로세스를 실행하는데 필요한 `메타 데이터`를 저장하는 자료구조
- 프로그램이 메모리에 올라와 PCB를 얻었을 때 비로소 프로세스가 됨
- `프로세스 상태 관리`와 `문맥 관리(context switching)`을 위해 필요

### PCB의 구조

- 포인터 : 부모, 자식 프로세스에 대한 포인터, 프로세스가 위치한 메모리 주소 포인터 등
- 프로세스 스케줄링 상태 : 프로세스의 상태(New, Ready, Running, Blocked, Terminated)를 저장
- 프로세스 ID : 프로세스 고유의 ID를 저장
- 프로그램 카운터 : 프로세스에서 `다음으로 실행할 명령어의 주소`를 저장
- CPU 레지스터 및 일반 레지스터
- CPU 스케줄링 정보 : 우선 순위, 최종 실행 시각, CPU 점유 시간 등
- 계정 정보 : 실행한 유저의 정보
- 입출력 상태 정보 : 프로세스에 할당된 입출력 장치 목록

### 컨텍스트 스위칭(Context Switching)

- context : CPU가 해당 프로세스를 실행하기 위한 정보들로, PCB에 저장된 정보를 가리킴
- 여러개의 프로세스가 실행되고 있을 때 기존에 실행되던 프로세스를 중단하고 다른 프로세스를 실행하는 것
- 한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생
- 컴퓨터가 많은 프로그램이 동시에 실행되는 것처럼 보이게 함

### 컨텍스트 스위칭 과정

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcLs4ee%2Fbtq6zCgeEaS%2FeMkhgp9failtca7VYSgbkk%2Fimg.png)

> - 프로세스 P<sub>0</sub>와 프로세스 P<sub>1</sub>가 컨텍스트 스위칭 하는 과정
>
> 1. 인터럽트, 또는 시스템 콜에 의한 요청이 발생
> 2. 운영체제가 현재 실행 중인 프로세스 P<sub>0</sub>의 정보를 PCB에 저장
> 3. 운영체제가 다음 프로세스 P<sub>1</sub>를 CPU에 할당하여 실행
> 4. 반복(P<sub>1</sub> -> P<sub>0</sub>)

### 컨텍스트 스위칭 오버헤드

- 컨텍스트 스위칭을 하는 동안 CPU가 아무일도 하지 않는 유휴 시간(idle)이 발생
- 캐시미스 : 컨텍스트 스위칭이 일어나면 이전에 실행 중이던 프로세스의 정보는 쓸모가 없어질 확률이 높음 -> 캐시를 비워버림 -> 메모리에서 캐시로 데이터를 다시 로드시킴

- 스레드 단위의 컨텍스트 스위칭 : 스레드는 스택을 제외한 자원(Code, Data, Heap 영역)은 모두 공유하기 때문에 스위칭 비용이 작고, 속도도 빠름
