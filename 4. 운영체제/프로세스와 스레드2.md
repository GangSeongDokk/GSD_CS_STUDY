# 멀티프로세싱

## 멀티 프로세싱이란

- 여러개의 프로세스를 사용하여 동시에 두 가지 이상의 일을 수행할 수 있는 것을 의미한다.
- 하나 이상의 일을 병렬로 처리할 수 있다.
- 특정 프로세스의 메모리, 프로세스 중 일부에 문제가 생겨도 다른 프로세스를 이용하여 처리할 수 있어서 신뢰성이 높다.

웹 브라우저는 멀티프로세스 구조를 가지고 있으며, 내용은 아래와 같다.

![브라우저의 구조](https://github.com/GangSeongDokk/GSD_CS_STUDY/assets/109258608/b1888cee-005f-4b07-b7c7-2998cc46f590)

- User Interface
    + 주소 표시줄, 이전/다음 버튼 등이 위치해있는, 컨텐츠가 보여지는 부분을 제외한 부분이다.
- 브라우저 프로세스
    + User Interface와 랜더러 프로세스 사이의 동작을 제어하고 렌더러 프로세스를 관리한다.
    + 주소 표시줄의 주소가 변경되면 렌더러 프로세스를 사용해 이를 다시 그린다.
    + 페이지에서 입력이 발생하면 이를 렌더러 프로세스에 전달한다.
- 렌더러 프로세스
    + 브라우저에서 보여지는 컨텐츠를 실제로 그리는 역할을 수행한다.
- UI 백엔드
    + OS의 UI를 참조하여 버튼, 체크 박스 등의 기본 요소들을 그린다.
- 네트워크
    + HTTP, FTP 등의 네트워크 통신 요청을 수행하고 통신 관련 보안 문제를 처리한다.
- JS 인터프리터
    + JS 코드를 해석하고 실행하는 **V8엔진**이 여기에 속해있다.
        * **[V8 엔진](https://evan-moon.github.io/2019/06/28/v8-analysis/)** : 구글이 주도하여 C++로 작성된 고성능의 자바스크립트 & 웹 어셈블리 엔진
- 플러그인 프로세스
    + 웹 사이트에서 사용하는 플러그인을 제어한다.
- GPU 프로세스
    + GPU를 이용해서 화면을 그리는 부분을 제어한다.
- 데이터 저장소
    + *Local storage*, *Cookie*와 같은 데이터를 로컬에 저장한다.


# 브라우저가 가지는 프로세스

- 웹 브라우저가 가져야하는 표준은 없다. 하지만 여기서는 대표적으로 크롬 브라우저에 대해 설명한다.

- 크롬 브라우저는 여러개의 프로세스로 이루어지며 각 프로세스는 각자에게 할당된 메모리를 가진다. 프로세스간 공유할 메모리가 있거나 통신해야할 일이 있으면 IPC를 사용하여 통신하여야한다.

- 프로세스는 여러개의 스레드로 구성되고 스레드끼리는 메모리를 공유할 수 있다.

## 왜 멀티 프로세스인가
```
싱글 프로세스였다면 브라우저에서 여러 탭을 켠 상황에서 하나의 잘못된 페이지에 접근할 경우, 혹은 렌더링에 문제가 생길 경우 브라우저 전체가 종료될 수 있다.
    
프로세스 분리를 통해 각 프로세스가 접근 가능한 메모리 범위를 격리하고 보호할 수 있다.
```

- 크롬 브라우저는 여러 프로세스를 가지지만 브라우저 프로세스와 렌더러 프로세스이다.  브라우저 프로세스는 단 한개이지만 렌더러 프로세스는 여러개일 수 있다. 크롬의 경우 기본적으로 탭마다 렌더러 프로세스를 생성한다.

- 프로세스가 너무 많거나 쉬고 있는 프로세스가 있는 경우 렌더러 프로세스를 재사용하기도 한다.

- 크롬은 사이트 별로 렌더러 프로세스를 따로 할당하여 사이트 격리를 구현한다.
    + 사이트 격리란 서로 다른 웹사이트의 페이지가 항상 다른 프로세스에 할당되도록 하는 것이다.
    + 사이트 내에 다른 사이트를 가리키는 **iframe**이 있을 경우 거기에도 다른 프로세스가 할당된다.
    + 이렇게 함으로서 **SOP**을 지킬 수 있다.
        * [SOP(동일 출처 정책)과 CORS(교차 출처 리소스 공유)](https://yoo11052.tistory.com/139)

- 이러한 멀티 프로세스의 단점은 메모리가 비효율적으로 운영될 수 있다는 것이다. 프로세스간에는 메모리가 공유되지 않으므로 프로세스간에 공통으로 가지고 있어야하는 부분(V8 등)을 각 프로세스별로 전부 복사해서 가지고 있는 경우가 있다.

- 크롬은 메모리를 절약하기 위해 기기에 따라 실행가능한 프로세스를 제한하고, 한계에 달할 경우 여러 탭을 하나의 프로세스에서 처리하기도 한다.

# 브라우저 프로세스

- 브라우저 프로세스는 최상위 프로세스로서 User Interface 부분을 제어하고, 각 프로세스들을 조율하는 역할을 한다.

- 브라우저 프로세스는 메인 UI(User Interface) 스레드와 I/O 스레드를 항상 유지한다.

- 메인 UI 스레드는 탭을 관리하고, I/O 스레드를 이용하여 렌더러 프로세스와 통신하며 렌더러 프로세스가 UI를 그리도록 한다.

- I/O 스레드는 렌더러 프로세스와 IPC 통신, 네트워크 통신을 처리한다.
    + 예를 들어 주소창에 naver.com을 입력하고 엔터를 치면 I/O 스레드로 naver.com에 콘텐츠를 요청한다.
    + 콘텐츠가 도착하면 메인 UI 스레드는 렌더러 프로세스에게 I/O 스레드를 통해 화면을 그리도록 요청하고, I/O 스레드는 받은 콘텐츠를 렌더러 프로세스에 전달한다.

# 렌더러 프로세스

- 렌더러 프로세스는 HTML과 CSS, Javascript를 사용자가 상호작용을 할 수 있는 웹 페이지로 그리는 것이다.

- 메인 스레드와 렌더 스레드라는 두가지 스레드를 유지한다.
    + 메인 스레드는 렌더 스레드 및 브라우저 프로세스와의 통신을 위한 RenderProcess 객체가 존재한다.
    + 렌더 스레드는 크로므이 렌더링 엔진인 Blink(혹은 Webkit)를 통해서 화면을 그린다.
    + 렌더러 프로세스는 필요에 따라 워커 스레드를 이용하여 JS 코드의 일부를 처리하거나, 페이지를 부드럽게 렌더링 하기 위한 컴포지터 스레드, 래스터 스레드를 실행하기도 한다.

- **[브라우저가 움직이는 방식](https://velog.io/@chltjdrhd777/%ED%81%AC%EB%A1%AC-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%93%A4)**

# IPC

- IPC(Inter Process Communication)는 프로세스끼리 데이터를 주고받고 공유데이터를 관리하는 메커니즘을 의미한다. 클라이언트와 서버를 예로 들 수 있다.

- IPC의 종류로는 공유 메모리, 파일, 소켓, 익명 파이프, 명명 파이프, 메시지 큐가 있다. 이들은 모두 메모리가 완전히 공유되는 스레드보다는 속도가 느리다.

## 공유 메모리

- 공유 메모리(shared memory)는 여러 프로세스에 동일한 메모리 블록에 대한 접근 권한이 부여되어 프로세스가 서로 통신할 수 있도록 공유 메모리를 생성해서 통신하는 것을 의미한다.

- 각 프로세스의 메모리에는다른 프로세스가 접근할 수 없지만, 공유 메모릴르 통해 여러 프로세스가 하나의 메모리를 공유할 수 있다. 메모리 자체를 공유하므로 IPC보다도 더 빠르며, 같은 메모리를 공유하는만큼 동기화가 필요하다.

## 파일

- 디스크에 저장된 데이터 또는 파일 서버에서 제공한 데이터를 의미한다. 이를 기반으로 프로세스간 통신을 한다.

## 소켓

- 동일한 컴퓨터의 다른 프로세스나 네트워크의 다른 컴퓨터로 네트워크 인터페이스를 통해 전송하는 데이터를 의미한다. [TCP와 UDP](#tcp와-udp)가 있다.


## 익명 파이프

- 익명 파이프(unnamed pipe)는 프로세스간에 FIFO 방식으로 읽히는 임시 공간인 파이프를 기반으로 데이터를 주고 받으며, 단방향 방식의 읽기 전용 / 쓰기 전용 파이프를 만들어 작동한다.

- 부모, 자식 프로세스 간에만 사용할 수 있고, 다른 네트워크 상에서는 사용이 불가능하다.

## 명명된 파이프

- 명명된 파이프(named pipe)는 파이프 서버와 하나 이상의 파이프 클라이언트 간의 통신을 위해 명명된 단방향 또는 양방향 파이프를 의미한다.

- 클라이언트 / 서버 통신을 위한 별도의 파이프를 제공하고, 여러 파이프를 동시에 사용할 수 있다.

- 프로세스끼리뿐 아니라 다른 네트워크의 컴퓨터와도 통신할 수 있다.

## 메시지 큐

- 메시지를 Queue 데이터 구조 형태로 관리하는 방식이며, 커널의 전역병수 형태 등으로 커널에서 전역적으로 관리된다.

- 다른 IPC 방식에 비해 사용 방법이 직관적이고 간단한 장점이 있어, 동기화가 복잡한 공유 메모리의 대안으로 사용되기도 한다.

# 스레드와 멀티스레딩

- 스레드는 프로세스의 실행 가능한 가장 작은 단위이며, 프로세스는 여러 스레드를 가질 수 있다.

- 코드, 데이터, 스택, 힙을 각각 생성하는 프로세스와 달리, 스레드끼리는 서로 공유한다. 그 이외의 영역은 각각 생성된다.

## 멀티스레딩

- 프로세스 내의 작업을 여러개의 스레드, 멀티스레드로 처리하는 기법이며 스레드끼리 자원을 공유하기에 효율성이 높다.
    + 예시로 웹 요청을 처리할때 새 프로세스 대신 새 스레드를 생성하는 웹 서버의 겨우 훨씬 적은 리소스를 사용한다.
    + 한 스레드가 중단되어도 다른 스레드가 실행 상태이면 이를 대신 처리할 수 있어 중단없는 빠른 처리가 가능하다.
    + 동시성에도 큰 장점이 있다.
        * 동시성 : 서로 독립적인 작업들을 작은 단위로 나누어 처리하여 동시에 실행되는 것처럼 보여주는 것
    + 하지만 한 스레드에 문제가 생기면 다른 스레드도 영향을 받을 가능성이 존재한다.
- 이러한 멀티스레드에는 렌더러 프로세스가 있다.

# 공유 자원과 임계 영역

## 공유 자원

- 공유자원(shared resource)는 시스템 안에서 프로세스, 스레드가 함께 접근할 수 있는 프린터, 메모리, 파일, 데이터 등의 자원이나 변수 등을 의미한다.

- 동일 공유자원에 두개 이상의 프로세스가 동시에 접근하는 상황을 경쟁 상태(race condition)이라고 한다. 이 상황에서는 접근 타이밍이나 순서 등이 결과값에 영향을 줄 수 있다.

## 임계 영역

- 임계 영역(critical section)은 둘 이상의 프로세스, 스레드가 공유자원에 접근할때 순서 등의 이유로 결과가 달라지는 코드 영역을 의미한다.

- 이러한 임계 영역을 해결하기 위해 크게 뮤텍스, 세마포어, 모니터 세가지 방법을 사용하며 셋 모두 상호 배제, 한정 대기, 융통성의 조건을 만족한다.
    + 상호 배제 : 한 프로세스가 임계영역에 들어가면 다른 프로세스는 들어갈 수 없다.
    + 한정 대기 : 특정 프로세스가 영원히 임계영역에 들어가지 못하는 경우가 생기면 안된다.
    + 융통성 : 어떤 프로세스가 다른 프로세스의 일을 방해하면 안된다.

- 기본적인 개념으로 잠금(lock)을 사용하는데, 한 프로세스 혹은 스레드가 사용중인 공유자원은 다른 프로세스나 스레드가 접근하지 못하도록 잠그는 방법이다.

### 뮤텍스

- 뮤텍스는 프로세스나 스레드가 공유 자원을 사용할때 그 자원을 잠그고, 사용이 종료되면 잠금 해제하는 객체이다. 뮤텍스는 잠금 혹은 잠금 해제의 두 상태만을 가진다.

### 세마포어

- 일반화된 뮤텍스로서, 간단한 정수값과 두가지 함수(wait, signal)로 공유자원에 대한 접근을 처리한다. wait은 자신의 차례가 올때까지 기다리는 함수이며, signal은 다음 프로세스로 순서를 넘겨주는 함수이다.

- 프로세스나 스레드가 공유 자원에 접근하면 세마포어에서 wait() 작업을 수행하고, 공유자원 사용을 종료하면 세마포어가 signal() 작업을 수행한다.

- 세마포어에는 조건 변수가 없고, 어떤 프로세스 및 스레드가 세마포어 값을 수정할때 다른 프로세스나 스레드는 동시에 세마포어 값을 수정할 수 없다.

#### 바이너리 세마포어

- 0과 1의 두가지 값만 가질 수 있는 세마포어이다.

- 뮤텍스는 바이너리 세마포어와 유사해 보이나, 엄밀히는 뮤텍스는 잠금을 기반으로 상호배제가 일어나는 **잠금 메커니즘**이고 세마포어는 신호를 기반으로 상호 배제가 일어나는 **신호 메커니즘**이다.

#### 카운팅 세마포어

- 여러 값을 가질 수 있는 세마포어이며, 여러 자원에 대한 접근을 제어하는데 사용된다.

### 모니터

- 모니터는 둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대한 인터페이스만 제공한다.

- 모니터는 세마포어보다 구현하기 쉬우며 상호 배제는 자동으로 이루어지지만, 세마포어에서는 상호 배제를 명시적으로 구현해야한다.

# 교착 상태

- 교착 상태(deadlock)이란 두개 이상의 프로세스가 서로가 가진 자원을 기다리며 중단된 상태를 말한다.

## 교착상태의 원인

- 상호 배제 : 한 프로세스가 자원을 독점하고 있어 다른 프로세스가 접근할 수 없다.

- 점유 대기 : 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하고 있는 상태이다.

- 비선점 : 다른 프로세스의 자원을 강제로 가져올 수 없다.

- 환형 대기 : 프로세스들이 서로가 가진 자원을 요구하는 상태이다.

## 교착 상태의 해결 방법

- 자원을 할당할때 애초에 조건이 성립되지 않도록 설계한다.

- 교착 상태 가능성이 없을때만 자원이 할당되고, 프로세스당 요청할 자원들의 최대치를 설정하여 자원할당 가능 여부를 파악하는 **은행원 알고리즘**을 사용한다.
    + **은행원 알고리즘** : 총 자원의 양과 현재 할당한 자원의 양을 기준으로 안정 상태 또는 불안정 상태로 나누어 안정 상태로 가도록 자원을 할당하는 알고리즘

- 교착 상태가 발생하면 사이클이 있는지 확인하고 이에 관련된 프로세스를 한개씩 지운다.

- 교착 상태는 매우 드물게 발생하므로, 이를 처리하는 비용이 더 커서 교착 상태가 발생하면 사용자가 직접 작업을 종료한다.
    + '응답없음'이 발생한 상황을 생각하면 된다.



# [TCP와 UDP](https://mangkyu.tistory.com/15)

## TCP(Transmission Control Protocol)

> 인터넷 상에서 데이터를 메시지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜

![TCP](https://github.com/GangSeongDokk/GSD_CS_STUDY/assets/109258608/d6a7cd52-87a7-450d-b793-fcc85200944e)

- TCP는 연결형 서비스를 지원하는 프로토콜로서 패킷을 추적 관리하며 인터넷 환경에서 기본으로 사용한다.

- 3-way handshaking을 통해 세션을 만들어 연결을 생성하고 4-way handshaking을 통해 해제한다.

- 출발지와 도착지를 확실하게 하여 정확한 전송을 보장하여 높은 신뢰성을 가지지만 UDP보다 속도는 떨어진다.

- 데이터의 **흐름 제어**와 **혼잡 제어** 가능하다.
    + **데이터의 흐름 제어(Flow Control)** : 데이터 송신자와 수신자 양측이 처리 가능한 정도로 데이터 송수신 속도를 조절하여, 수신자의 버퍼 오버플로우를 방지하는것
    + **데이터의 혼잡 제어(Congestion Control)** : 네트워크 내의 패킷 수가 과도하게 증가하지 않도록 패킷의 숫자를 제어하는것

## UDP(User Datagram Protocol)

> 데이터를 **데이터그램** 단위로 처리하는 프로토콜

**데이터그램** : 독립적인 관계를 가지는 패킷

![UDP](https://github.com/GangSeongDokk/GSD_CS_STUDY/assets/109258608/5b97437e-b090-4743-9758-70fcfcdcd76a)

- 비연결형 프로토콜로서 연결을 위하여 할당되는 논리적인 경로가 없으며 각각의 패킷은 각자 다른 경로로 전달되어 독립적인 관계를 가지게 된다.

- 데이터를 송수신할때 데이터를 보내거나 받는다는 신호절차를 거치지 않는다.

- UDP 헤더의 CheckSum 필드를 통해 최소한의 오류만 검출하므로 신뢰성이 낮지만, TCP보다 속도가 빠르다.

- 데이터 흐름 제어가 불가능하다.

- 데이터그램의 최대 크기는 65535바이트이며 크기가 초과할 경우 잘라서 보낸다.

|프로토콜 종류|TCP|UDP|
|-|-|-|
|연결방식|연결형 서비스(패킷 교환 방식)|비연결형 서비스(데이터그램 방식)|
|전송 순서|전송 순서를 보장함|전송 순서를 보장하지 않음|
|수신 여부 확인|수신 여부를 확인함|수신 여부를 확인하지 않음|
|통신 방식|1:1 통신|1:1, 1:N, M:N 통신|
|신뢰성|높다|낮다|
|속도|느리다|빠르다|

[위로](#ipc)