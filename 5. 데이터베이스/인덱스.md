# 인덱스의 필요성

- 인덱스를 설정하면 테이블 안에서 내가 찾고자하는 데이터를 빠르게 찾을 수 있다.

# 인덱스의 구성

- 인덱스는 보통 [**B-트리**](#b-트리)라는 자료 구조로 이루어져 있는데, 이는 루트노드와 리프노드, 그리고 그 사이의 브랜치 노드로 나뉜다.

# 인덱스가 효율적인 이유

- 인덱스가 효율적인 이유는 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 **균형잡힌 트리 구조**와 **트리 깊이의 대수확장성** 때문이다.
    + **트리 깊이의 대수 확장성** : 트리의 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 의미한다. 인덱스가 한 깊이 증가할때마다 최대 인덱스 항목의 수는 4배씩 증가한다.

# 인덱스를 생성하는 방법

## MySQL

- 클러스터형 인덱스와 세컨더리 인덱스가 있으며, 클러스터형 인덱스는 테이블당 하나를 설정할 수 있다.

- primary key 옵션으로 기본키로 만들었다면 클러스터형 인덱스를 생성할 수 있고, unique not null 옵션을 썼다면 클러스터형 인덱스로 만들 수 있다.

- create index... 명령어를 기반으로 만들면 세컨더리 인덱스를 만들 수 있다.

- 하나의 인덱스만 만들 것이라면 클러스터형 인덱스를 만드는 것이 세컨더리 인덱스를 만드는 것보다 성능이 좋다.

- 세컨더리 인덱스는 보조 인덱스로 여러캐의 필드값을 기반으로 쿼리를 많이 보낼 때 생성해야하는 인덱스이다.

## MongoDB

- MongoDB의 경우 도큐먼트를 만들면 자동으로 ObjectID가 형성되며, 해당 키가 기본키로 설정된다.

- 세컨더리키를 부가적으로 생성하여 기본키와 세컨더리키를 같이 사용하는 복합 인덱스를 설정할 수 있다.

# 인덱스 최적화 기법

- 인덱스 최적화 기법은 데이터베이스마다 조금씩 다르지만 기본적인 골조는 똑같기 때문에 특정 데이터베이스를 기준으로 설명해도 무방하다.

- 여기서는 MongoDB를 기준으로 설명한다.

## 1. 인덱스는 비용이다

- 인덱스를 사용하게 되면 탐색을 두번 실시해야한다. 인덱스 리스트를 우선, 이후 컬렉션을 탐색하게 되기 때문이며 이로 인한 읽기 비용이 발생한다.

- 컬렉션이 수정된다면 인덱스도 수정되어야하는데, 이때 B-트리의 높이를 균형있게 조절하는 비용과 데이터를 효율적으로 조회할 수 있도록 분산시키는 비용도 들게 된다.

- 컬렉션에서 가져와야하는 데이터의 양이 많을수록 인덱스를 사용하는 것은 비효율적이다. 따라서 모든 필드에 인덱스를 설정하는 것은 현명하지 않다.

## 2. 항상 테스팅한다

- 인덱스 최적화 기법은 서비스 특징에 따라 달라진다. 서비스에서 사용하는 객체의 깊이와 테이블의 양도 다르기 때문이며, 그렇기에 테스트는 중요하다.

- explain() 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스팅을 하며 걸리는 시간을 최소화해야 한다.

- 다음은 MySQL에서 주로 사용하는 테스트 코드이다.


```sql
EXPLAIN
SELECT * FROM t1
JOIN t2 ON t1.c1 = t2.c1
```

## 3. 복합인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다.

- 여러 필드를 기반으로 조회를 할때 복합 인덱스를 생성하는 경우가 있는데, 이 인덱스는 생성 순서가 있고 그 순서에 따라 인덱스 성능이 달라진다.

- **같음**, **정렬**, **다중 값**, **카디널리티** 순으로 생성해야한다.
    + **같음** : 어떠한 값과 같음을 비교하는 `==`이나 `equal`이라는 쿼리가 있다면 제일 먼저 인덱스로 설정한다.
    + **정렬** : 정렬에 쓰는 필드라면 그 다음 인덱스로 설정한다.
    + **다중 값** : 다중 값을 출력해야하는 필드, 즉 쿼리 자체가 `>`이거나 `<` 등의 많은 값을 출력해야하는 쿼리에 쓰는 필드라면 나중에 인덱스를 설정한다.
    + **카디널리티** : 카디널리티는 유니크한 값의 정도를 의미한다. 카디널리티가 높은 순서를 기반으로 인덱스를 생성해야한다. `이름`과 `나이`가 있다면, 당연히 `이름`이라는 필드에 대한 인덱스를 먼저 생성해야한다.



# B-트리

# B-트리의 특징

- 노드에는 2개 이상의 데이터가 들어갈 수 있으며, 항상 정렬된 상태로 저장된다.

![B-트리](https://github.com/GangSeongDokk/GSD_CS_STUDY/assets/109258608/a36e71cd-f6e6-4ebf-8dd9-b70b16adaeab)

- 내부 노드는 M/2 ~ M개의 자식을 가질 수 있다. 최대 M개의 자식을 가질 수 있는 B-트리를 M차 B-트리라고 한다.

![B-트리2](https://github.com/GangSeongDokk/GSD_CS_STUDY/assets/109258608/06ace53c-85c6-4890-b4f8-680a69468e01)

- 특정 노드의 데이터(key)가 K개라면, 자식 노드의 개수는 K+1개여야한다.

![B-트리3](https://github.com/GangSeongDokk/GSD_CS_STUDY/assets/109258608/30f5e7c2-048e-4e8e-b7ff-d3f7b9e9ae29)

- 특정 노드의 왼쪽 서브 트리는 해당 노드의 key보다 작은 값들로, 오른쪽 서브트리는 큰 값들로 구성된다.

![B-트리4](https://github.com/GangSeongDokk/GSD_CS_STUDY/assets/109258608/e708b6a4-cdaf-4994-b818-ac907230d905)

- 노드 내의 데이터는 floor(M/2)-1개부터 최대 M-1개까지 포함될 수 있다. (floor = 내림 함수)

![B-트리5](https://github.com/GangSeongDokk/GSD_CS_STUDY/assets/109258608/4f9e7cb6-bd94-4f37-9c6c-fa209a6641f5)

- 모든 리프 노드들이 같은 레벨에 존재한다.

![B-트리6](https://github.com/GangSeongDokk/GSD_CS_STUDY/assets/109258608/1d4d3e37-caad-4cb3-9165-4c52dbad5425)


# [B-트리의 탐색 과정](https://code-lab1.tistory.com/217)

1. 루트노드에서 탐색을 시작한다.

2. 원하는 값을 찾았다면 탐색을 종료한다.

3. key값과 찾고자하는 값을 비교해 알맞은 자식 노드로 내려간다.

4. 위의 과정을 리프 노드에 도달할 때까지 반복한다.

5. 리프노드에서도 원하는 값을 찾지 못했다면 트리에 값이 존재하지 않는 것이다.


![B-트리 탐색1](https://github.com/GangSeongDokk/GSD_CS_STUDY/assets/109258608/6d9487de-6c2c-435d-ba02-53fd26c5b2b1)

![B-트리 탐색2](https://github.com/GangSeongDokk/GSD_CS_STUDY/assets/109258608/7747e943-040b-442a-939c-1de65a1df764)

![B-트리 탐색3](https://github.com/GangSeongDokk/GSD_CS_STUDY/assets/109258608/0ff296bc-3872-4682-ba75-6e1aeac1fb02)

![B-트리 탐색4](https://github.com/GangSeongDokk/GSD_CS_STUDY/assets/109258608/17ba3826-7f41-482d-8985-604e04bf2101)


[위로](#인덱스가-효율적인-이유)