# HTTP란

HTTP는 전송계층 위에 있는 애플리케이션 계층으로서 웹 서비스 통신에 사용된다.

# HTTP/1.0

1.0은 기본적으로 한번의 연결동안 하나의 요청을 처리한다.

서버로부터 파일을 하나 가져올때마다 TCP 3-way handshake를 계속해서 반복해야하기 때문에 이는 패킷 왕복시간을 증가시켜 서버에 부담이 많이 가고 사용자 응답 시간이 길어지게 되었다.

이러한 문제를 해결하기 위해 이미지 스플리팅, 코드 압축, 이미지 Base64 인코딩을 사용하였다.

## 이미지 스플리팅

많은 이미지를 다운로드 받게 되면 서버에 과부하가 걸릴 수 있기에, 많은 이미지가 합쳐져 있는 하나의 이미지를 다운로드받고, 이를 기반으로 background-image의 position을 이용하여 이미지를 표기하는 방법

한번의 요청으로 많은 이미지를 표현할 수 있다.

## 코드 압축

코드를 압축하여 개행문자, 빈칸을 없애는 방식으로 코드의 크기를 최소화하는 방법

```javascript
const express = require('express')
const app = express()
const port = 3000

app.get('/', (req,res) => {
    res.send('hello world')
})
```
위의 코드를 아래와 같이 압축하여 용량을 줄인다.
```javascript
const express=require("express"),app=express(),port=3e3;app.get("/", (e,p)=>{p.send("hello world")})
```

## 이미지 Base64 인코딩

이미지 파일을 64진법으로 이루어진 문자열로 인코딩하는 방법.

![base64](https://github.com/GangSeongDokk/GSD_CS_STUDY/assets/109258608/c88a1c73-feff-428a-ac70-075fe81ce733)

이러한 방식은 binary데이터를 텍스트 기반 규격으로 다룰 수 있도록 해주어 서버에 이미지를 요청하지 않아도 되지만, 대신 용량이 37%정도 더 커지는 단점이 있다.

### 변환 방식
- 24bit의 버퍼를 사용하여 데이터를 넣은 뒤, 6bit단위로 잘라 base64 테이블의 ASCII문자로 변환한다.

- 예를 들어 'Man'이라는 글자를 변환한다면 아래와 같다.

![base64-2](https://github.com/GangSeongDokk/GSD_CS_STUDY/assets/109258608/8a159da4-ed38-4100-bfe1-26b5b55d2235)

# HTTP/1.1

1.0에서 더 발전한 방식. 매번 TCP 연결을 하지 않고, 한번 TCP 연결이 초기화 되면 keep-alive라는 옵션을 사용해 여러개의 파일을 송수신할 수 있도록 한다.

1.0에도 있긴 했으나 표준화 되지 않았고, 1.1부터 표준화되어 기본 옵션으로 설정되었다.

아래와 같이, 한번 TCP 3-way handshake가 발생하여 연결이 성립되면 이후에는 다시 발생하지 않는 것을 알 수 있다.

![http1dot1](https://github.com/GangSeongDokk/GSD_CS_STUDY/assets/109258608/839ec942-2906-4c72-a0a6-fd6147950636)

하지만 1.1의 헤더에는 쿠키 등 많은 메타데이터가 들어있으며, 압축이 되지 않아 무거운 구조를 가지고 있었다.

그리고 문서 안에 다수의 리소스가 포함되어 있다면, 그 리소스 개수에 비례하여 대기 시간이 길어지는 단점이 있다. 그 예시로 HOL Blocking이 있다.

## HOL Blocking(Head Of Line Blocking)

네트워크에서 같은 큐에 있는 패킷이 그 첫번째 패킷에 의해 지연될때 발생하는 성능 저하 현상.

1번, 2번, 3번 요청이 들어갔을때, 1번 요청을 처리하는 것이 늦어진다면 2번, 3번 요청의 응답 역시 늦어지게 된다.

![HOLblocking](https://github.com/GangSeongDokk/GSD_CS_STUDY/assets/109258608/af43aeab-9d66-4f49-b594-98117c0390bb)


# HTTP/2

2는 1.x보다 지연시간을 줄이고 응답시간을 빠르게 했으며, 멀티플렉싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리를 지원하는 프로토콜이다.

## 멀티플렉싱

여러개의 스트림을 사용하여 송수신하는 것. 이를 통해 특정 스트림의 패킷이 손실되었다고 하더라도 해당 스트림에만 영향을 미치고 나머지는 잘 작동하게 만들 수 있다.

이러한 방식을 사용하면 한번 구축된 연결을 통해 여러 스트림을 병렬로 전송하여 요청과 응답을 주고 받을 수 있으며, 데이터의 조각들이 준비되는 대로 송수신하므로 HOL Blocking 역시 해결된다.

### 스트림
데이터, 패킷, 비트 등의 작은 조각들이 하나의 줄기를 이루며 전송되는, 잘게 분할된 데이터들의 연속적인 흐름이다.

## 헤더 압축

허프만 코딩 압축 알고리즘을 사용하는 HPACK 압축 형식을 통해 헤더의 크기를 줄였다.

### 허프만 코딩

문자열을 문자 단위로 쪼개 빈도수를 세어 빈도가 높은 정보는 적은 비트수를 사용하여 표현하고, 빈도가 낮은 정보는 비트 수를 많이 사용하여 표현하는 것으로 전체 데이터의 표현에 필요한 비트수를 줄이는 원리.

## 서버 푸시

클라이언트가 서버에 요청을 해야 파일을 받을 수 있었던 1.1과는 다르게, 2는 클라이언트의 요청이 없어도 서버가 바로 리소스를 푸시할 수 있다.

html에는 css나 js 파일이 함께하기 마련인데, html에 대해서만 요청이 들어와도 css파일과 js파일도 함께 서버측에서 푸시하여 클라이언트에게 보낼 수 있게 된다.

# HTTPS & SSL/TLS

HTTPS/2는 HTTPS위에서 동작한다. HTTPS란 애플리케이션 계층과 전송 계층 사이에 신뢰계층인 SSL/TLS 계층을 넣은 신뢰할 수 있는 HTTP요청이며 이를 통해 통신을 암호화한다.

SSL(Secure Socket Layer)은 SSL 1.0부터 시작해서 SSL 2.0, SSL 3.0, TLS(Transport Layer Security Protocol) 1.0, TLS 1.3까지 버전이 올라가며 마지막으로 TLS로 명칭이 변경되었지만, 보통 둘을 합쳐서 SSL/TLS라고 많이 부른다. (이후로는 최신 TLS 버전인 TLS 1.3을 기반으로 설명한다.)

SSL/TLS는 전송 계층에서 보안을 제공하는 프로토콜이며, 이를 통해 클라이언트와 서버가 통신할때 제3자가 메시지를 도청하거나 변조하지 못하게 만든다.

이러한 암호화는 보안 세션을 기반으로 이루어지며, 보안 세션이 만들어질때, 인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘이 사용된다.

## 보안 세션

보안이 시작되고 끝나는 동안 유지되는 세션을 의미하며, SSL/TLS handshake를 통해 보안 세션을 생성하고 이를 기반으로 상태 정보등을 공유한다.

클라이언트와 서버가 키를 공유하고 이를 기반으로 인증, 인증 확인 등의 작업이 일어나는 1-RTT가 생긴 후 데이터를 송수신한다. TLS 1.3에서 2-RTT가 1-RTT로 줄었다.

TLS 1.3은 이전 방문시의 키를 서로가 저장해두었다가 다음 방문 즉시 통신을 개시하는 0-RTT도 지원한다.

클라이언트에서 사이퍼 슈트(cypher suites)를 서버에 전달하면 서버는 받은 사이퍼 슈트의 암호화 알고리즘 리스트를 제공할 수 있는지 확인하고, 제공할 수 있다면 서버에서 클라이언트로 인증서를 보내는 인증 메커니즘이 시작되며 이후 해싱 알고리즘 등으로 암호화된 데이터의 송수신이 시작된다.

### 세션

세션이란 운영체제가 어떠한 사용자에게 일정한 시간동안 자신의 리소스 사용을 허가할 때, 그 시간을 가리킨다.

### 사이퍼 슈트

사이퍼 슈트란 프로토콜, AEAD 사이퍼 모드, 해싱 알고리즘이 나열된 규약을 말하며 다섯가지가 존재한다.

- TLS_AES_128_GCM_SHA256
- TLS_AES_256_GCM_SHA384
- TLS_CHACHA20_POLY1305_SHA256
- TLS_AES_128_CCM_SHA256
- TLS_AES_128_CCM_8_SHA256

예로, TLS_AES_128_GCM_SHA256에는 세가지 규약이 들어있는데, TLS는 프로토콜, AES_128_GCM은 AEAD 사이퍼모드, SHA256은 해싱 알고리즘을 의미한다.

### AEAD 사이퍼 모드

AEAD(Authenticated Encryption with Associated Data)는 데이터 암호화 알고리즘이다.

예를 들어, AES_128_GCM이라는 것은 128비트의 키를 사용하는 표준 블록 암호화 기술과 병렬 계산에 용이한 암호화 알고리즘 GCM이 결합된 알고리즘을 의미한다.

## 인증 메커니즘

CA(Certificate Authorities)에서 발급한 인증서를 기반으로 이루어진다.

인증서는 아전한 열결을 시작하는데 있어 필요한 공개키를 클라이언트에 제공하고 사용자가 접속한 서버가 신뢰할 수 있음을 보장한다.

인증서는 서비스 정보, 공개키, 지문, 디지털 서명 등으로 이루어져 있다.

신뢰성이 엄격하게 공인된 기업들만 CA에 참여할 수 있다.

자신의 서비스가 CA인증서를 발급받으려면 자신의 사이트 정보와 공개키를 CA에 제출해야한다.

이후 CA는 공개키를 해시한 값인 지문을 사용하는 CA의 비밀 키 등을 기반으로 CA 인증서를 발급한다.

## 암호화 알고리즘

키교환 암호화 알고리즘으로는 대수곡선 기반의 ECDHE(Elliptic Curve Diffie-Hellman Ephermeral) 또는 모듈식 기반의 DHE(Diffie-Hellman Ephermeral)를 사용한다.

둘다 디피-헬만 방식을 근간으로 하였는데 디피-헬만 키 교환 알고리즘은 다음과 같다.

```
y = g^x mod p
```

위의 식에서 g, x, p를 안다면 y는 쉽게 구할 수 있으나, g,y,p만 안다면 x를 구하기는 어렵다는 원리에 기반한다.

처음 공개값을 공유하고 각자의 비밀 값과 혼합한 후에 혼합 값을 공유하며, 이후 각자의 비밀 값과 또 혼합한다.

이후 공통의 암호키인 PSK(Pre-Shared Key)가 생성된다.

이렇게 클라이언트와 서버 모두 개인키와 공개키를 생성하고, 서로에게 공개키를 보내고 공개키와 개인키를 결합하여 PSK가 생성될 경우, 개인키 혹은 공개키가 새어나가도 PSK가 없이는 아무것도 할 수 없으며, 이로써 키를 암호화 할 수 있다.

## 해싱 알고리즘

데이터를 추정하기 힘든 더 작고 섞여있는 조각으로 만드는 알고리즘이다. SSL/TLS는 해싱 알고리즘으로 SHA-256과 SHA-384를 사용한다.

자주 사용하는 SHA-256 알고리즘은 해시 함수의 결과값이 256비트인 알고리즘이며, 비트코인을 비롯한 많은 블록체인 시스템에서도 사용한다.

해싱을 해야할 메시지에 1을 추가하는 등의 전처리를 하고, 이후 그 메시지를 기반으로 해시를 반환한다.

https://emn178.github.io/online-tools/sha256.html에서 다양한 해싱 알고리즘을 테스트해볼 수 있다.

### 해시

다양한 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑한 값

### 해싱

임의의 데이터를 해시로 바꿔주며, 해시 함수가 이를 담당한다.

### 해시함수

임의의 데이터를 입력으로 받아 일정한 길이의 해시 데이터를 반환하는 함수


## SEO(Search Engine Optimization)

검색엔진 최적화를 의미하며, 사용자들이 검색엔진으로 웹사이트를 검색했을때, 그 결과를 페이지 상단에 노출시켜 많은 사람이 볼 수 있도록 최적화 하는 방법을 의미한다.

이를 위한 방법으로 캐노니컬 설정, 메타 설정, 페이지 속도 개선, 사이트 맵 관리 등이 있다.

### 캐노니컬 설정

```html
<link rel="canonical" href="https://example.com/page1.php"/>
```
이처럼 사이트 링크에 캐노니컬을 설정할 수 있다.

### 메타 설정

메타는 html파일의 가장 윗부분이고, 이 부분을 잘 설정해야한다.

```html
<meta property="analytics-track" content="Apple - Index/Tab">
```

관련 설명은 다음의 사이트에 잘 되어 있다.
https://yozm.wishket.com/magazine/detail/816/


### 페이지 속도 개선

https://developers.google.com/speed/pagespeed/insites/

위 사이트에서 페이지 속도 리포트를 받아볼 수 있다.

### 사이트맵 관리

sitemap.xml을 정기적으로 관리하여야한다.

Sitemap은 검색 엔진에서 사이트를 보다 지능적으로 크롤링할 수 있도록, 크롤링에 사용할 수 있는 사이트의 페이지에 대한 정보를 검색 엔진에 알리는 방법이다.

XML 파일로 각 URL에 대한 추가 메타데이터(마지막 업데이트된 날짜, 변경 빈도, 사이트의 다른 URL에 상대적인 중요도)와 함께 사이트에 대한 URL을 나열하는 형식을 쓰게 된다.

```xml
<?xml version="1.0" encoding="utf-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
   <url>
      <loc>https://example.com/</loc>
      <lastmod>2021-05-14T10:00:54+09:00</lastmod>
      <changefreq>monthly</changefreq>
      <priority>0.8</priority>
   </url>
</urlset> 
```

## HTTPS 구축 방법

3가지가 존재한다.

- CA에서 구매한 인증키를 기반으로 구축

- 서버 앞단의 HTTPS를 제공하는 로드밸런서를 두어 구축

- 서버 앞단에 HTTPS를 제공하는 CDN을 두어 구축

# HTTP/3

TCP 위에서 돌아가는 2와는 달리 3은 QUIC이라는 계층 위에서 돌아가며, TCP 기반이 아닌 UDP 기반이다.

멀티플렉싱을 지원하며, 초기 연결 설정시 지연시간 감소라는 장점이 있다.

## 초기 연결 설정시 지연시간 감소

QUIC는 TCP를 사용하지 않기 때문에 통신을 시작할때 번거로운 3-way handshake 과정을 거치지 않는다.

QUIC은 첫 연결 설정에 1-RTT만 소요되며, 이는 클라이언트가 서버에 신호를 보내고 서버가 그 신호에 응답하면 바로 통신을 시작할 수 있다는 의미이다.

QUIC은 순방향 오류 수정 메커니즘(FEC, Forward Error Correction)이 적용되어 있어, 전송한 패킷이 손실되었다면 수신 측에서 에러를 검출하고 수정하는 방식이다.

이로 인해 열악한 네트워크 환경에서도 낮은 패킷 손실률이라는 장점을 가진다.