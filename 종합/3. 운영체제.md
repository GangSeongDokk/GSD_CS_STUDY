# 프로세스와 스레드의 차이는 무엇인가요?

- 프로세스 : 디스크로부터 메모리에 적재되어 CPU의 할당을 받아 실행중인 프로그램을 의미한다. 함수의 매개변수, 복귀 주소 및 로컬 변수 등을 저장하는 프로세스 스택과 전역 변수들을 저장하는 데이터 섹션, 프로세스 실행중 동적으로 할당되는 힙을 포함한다.
  + PCB(Process Control Block, 프로세스 제어 블록) : 프로세스에 대한 중요한 정보를 저장하는 블록을 의미한다. 운영체제는 프로세스의 생성과 동시에 고유한 PCB를 생성하며, 프로세스 전환이 발생할 시, 이 PCB에 현재 프로세스의 진행상황을 저장해 두게 된다. 그리고 다시 프로세서를 할당 받으면 PCB에 저장된 내용을 불러와 작업을 재수행한다.
    

- CPU(프로세서) 사용의 기본 단위를 의미한다. 같은 프로세스 내부의 스레드끼리는 메모리, 데이터 섹션, 코드 및 파일 등의 자원을 공유한다. 하나의 프로세스를 여러 스레드로 분리하여 자원을 관리하는 것을 통해 자원의 생성 및 관리의 중복을 막아 성능을 향상시키는 것을 멀티스레딩이라고 한다.
  + 스택을 각 스레드마다 독립적으로 할당하는 이유 : 스택은 함수의 전달 인자 및 로컬 변수등을 저장하는 공간으로, 이러한 메모리 공간이 독립적이라는 것은 독립적으로 함수를 호출하여 사용하는 것이 가능하다는 의미이며 이를 통해 각 스레드는 자신만의 독립된 실행 흐름을 가질 수 있게 된다.
  + PC Register를 각 스레드마다 독립적으로 할당하는 이유 : 스레드는 CPU를 할당 받았다가도 스케쥴러에 의해 CPU를 선점당하게 되며 이로인해 하나의 작업을 연속적으로 수행하지 못하므로 이전에 명령어가 어디까지 수행되었는지를 기억하는 PC값이 필요하다.

# 멀티 스레딩의 장점과 단점은 무엇인가요?

## 장점

- 멀티 스레딩을 사용하여 스레드를 여러개 구현하여 자원을 공유하게 되면, 자원의 중복을 막아 메모리공간과 시스템 자원의 소모를 줄일 수 있어 성능의 향상을 불러올 수 있다. 스레드간의 통신이 필요할 때도 힙 영역을 사용하여 상호 통신이 가능하다. 스레드의 **context switching**은 프로세스의 그것과는 달리 캐시 메모리를 비울 필요가 없어 더욱 간편하고 빠르게 일어나며 이 덕분에 자원소모가 줄어들어 프로그램의 응답시간을 단축시키고 성능을 향상시킨다.

  + context switching : 현재 실행중인 프로세스 혹은 스레드의 상태를 저장하고 다음 프로세스 및 스레드의 상태값을 읽어와 적용시키는 과정

## 단점

- 멀티 프로세스로 처리하는 경우 공유하는 자원이 없기에 같은 자원에 동시에 접근할 일이 없지만, 멀티 스레드의 경우 자원을 공유하므로 같은 자원에 동시에 여러 스레드가 접근하는 **동시성 문제**가 발생한다. 이를 해결하기 위해 동기화 작업이 필요하며 이 과정 중에서 과도한 락으로 인한 병목현상이 발생하거나 아예 데드락(교착상태)가 발생하여 작업이 중지될 수도 있기에 이 부분을 잘 고려해야한다.

# 멀티 프로세스와 멀티 스레드를 비교해주세요

- 멀티 스레드는 멀티 프로세스보다 시스템 자원을 덜 사용하고 context switching이 빠르다는 장점이 있지만, 오류로 인해 하나의 스레드가 종료되면 전체 스레드에 영향을 미칠 수 있다는 점과 동기화 문제란느 단점을 가지고 있다.

- 멀티 프로세스는 하나의 프로세스가 종료되어도 다른 프로세스는 영향을 받지 않고 정상적으로 작동할 수 있다는 장점이 있으나, 멀티 스레드에 비해 시스템 자원 소모가 심하고 context switching이 느리다는 단점이 있다.
 

# CPU 스케줄링 방법에 대하여 설명해주세요


- FCFS(First Come First Served)
  + 먼저 온 고객을 먼저 서비스해주는 방식, 즉 먼저 온 순서대로 처리.
  + 비선점형(Non-Preemptive) 스케줄링
    * 일단 CPU 를 잡으면 CPU burst 가 완료될 때까지 CPU 를 반환하지 않는다. 할당되었던 CPU 가 반환될 때만 스케줄링이 이루어진다.
  + 문제점
    * convoy effect : 소요시간이 긴 프로세스가 먼저 도달하여 효율성을 낮추는 현상이 발생한다.
 

- SJF(Shortest - Job - First)
  + 다른 프로세스가 먼저 도착했어도 CPU burst time 이 짧은 프로세스에게 선 할당
  + 비선점형(Non-Preemptive) 스케줄링
  + 문제점
    * starvation : 효율성을 추구하는게 가장 중요하지만 특정 프로세스가 지나치게 차별받으면 안되는 것이다. 이 스케줄링은 극단적으로 CPU 사용이 짧은 job 을 선호한다. 그래서 사용 시간이 긴 프로세스는 거의 영원히 CPU 를 할당받을 수 없다.
 

- SRT(Shortest Remaining time First)
  + 새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어진다.
  + 선점형 (Preemptive) 스케줄링
    * 현재 수행중인 프로세스의 남은 burst time 보다 더 짧은 CPU burst time 을 가지는 새로운 프로세스가 도착하면 CPU 를 뺏긴다.
  + 문제점
    * starvation : 새로운 프로세스가 도달할 때마다 스케줄링을 다시하기 때문에 CPU burst time(CPU 사용시간)을 측정할 수가 없다.
 

- Priority Scheduling

  + 우선순위가 가장 높은 프로세스에게 CPU 를 할당하겠다. 우선순위란 정수로 표현하게 되고 작은 숫자가 우선순위가 높다.
  + 선점형 스케줄링(Preemptive) 방식
    * 더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU 를 선점한다.
  + 비선점형 스케줄링(Non-Preemptive) 방식
    * 더 높은 우선순위의 프로세스가 도착하면 Ready Queue 의 Head 에 넣는다.
  + 문제점
    * starvation
    * 무기한 봉쇄(Indefinite blocking) : 실행 준비는 되어있으나 CPU 를 사용못하는 프로세스를 CPU 가 무기한 대기하는 상태
  + 해결책
    * aging : 아무리 우선순위가 낮은 프로세스라도 오래 기다리면 우선순위를 높여준다.
 

- Round Robin

  + 현대적인 CPU 스케줄링
  + 각 프로세스는 동일한 크기의 할당 시간(time quantum)을 갖게 된다.
  + 할당 시간이 지나면 프로세스는 선점당하고 ready queue 의 제일 뒤에 가서 다시 줄을 선다.
  + RR은 CPU 사용시간이 랜덤한 프로세스들이 섞여있을 경우에 효율적
  + RR이 가능한 이유는 프로세스의 context 를 save 할 수 있기 때문이다.
  + 장점
    * Response time이 빨라진다.
    * n 개의 프로세스가 ready queue 에 있고 할당시간이 q(time quantum)인 경우 각 프로세스는 q 단위로 CPU 시간의 1/n 을 얻는다. 즉, 어떤 프로세스도 (n-1)q time unit 이상 기다리지 않는다.
    * 프로세스가 기다리는 시간이 CPU 를 사용할 만큼 증가한다.
    * 공정한 스케줄링이라고 할 수 있다.
  + 주의할 점
    * 설정한 time quantum이 너무 커지면 FCFS와 같아진다. 또 너무 작아지면 스케줄링 알고리즘의 목적에는 이상적이지만 잦은 context switch 로 overhead 가 발생한다. 그렇기 때문에 적당한 time quantum을 설정하는 것이 중요하다.

 

# 동기와 비동기의 차이에 대해 말해주세요

Sync vs Async
- 일반적으로 동기와 비동기의 차이는 메소드를 실행시킴과 동시에 반환 값이 기대되는 경우를 동기 라고 표현하고 그렇지 않은 경우에 대해서 비동기 라고 표현한다.

- 동시에라는 말은 실행되었을 때 값이 반환되기 전까지는 blocking되어 있다는 것을 의미한다.

- 비동기의 경우, blocking되지 않고 이벤트 큐에 넣거나 백그라운드 스레드에게 해당 task 를 위임하고 바로 다음 코드를 실행하기 때문에 기대되는 값이 바로 반환되지 않는다.


- [그림으로 된 설명](http://asfirstalways.tistory.com/348)