# 1. 싱글톤 패턴

## 싱글톤 패턴의 정의

어플리케이션이 시작될때 어떤 클래스가 최초 한번만 메모리를 할당하여(static) 단 하나의 인스턴스만을 생성하여 사용하는 디자인 패턴

## 싱글톤 패턴의 장점

- 인스턴스가 하나뿐이므로 메모리가 한번만 할당되기 때문에 불필요한 메모리 낭비를 줄이고 생성 비용을 절약할 수 있다.

- 싱글톤 방식으로 만들어진 인스턴스는 전역이기 떄문에 프로그램의 어느 곳에서도 데이터를 공유할 수 있다.

- 인스턴스가 반드시 한개만 존재하는 것을 보증할 수 있다.

- 일단 한번 생성한 뒤에는 객체 로딩 시간이 줄어들어 성능이 개선된다.

## 싱글톤 패턴의 단점

- 싱글톤 인스턴스에 너무 많은 일이 주어질 경우 다른 클래스의 인스턴스들과 결합도가 높아져 의존성이 증가한다. 의존성이 높아지면 어떤 클래스가 변경될때, 거기에 높은 의존성을 가진 다른 클래스 역시 영향을 받아 변경될 가능성이 높아진다.

  + 이러한 의존성을 낮추기 위해서, 의존성 주입을 통해 모듈간의 결합도를 낮춰줄 수 있다. 의존성 주입을 통해 모듈들을 쉽게 교체할 수 있게 되어, 애플리케이션 의존성 방향이 일관되고, 애플리케이션을 쉽게 추론할 수 있으며, 모듈간의 관계들이 명확해진다.
  + 의존성 주입의 단점은 클래스 수가 늘어나서 복잡성이 상승하고 실행에 추가적인 시간이 걸리게 된다는 것이다.

- 멀티스레드 환경에서는 동기화를 염두에 두지 않으면 여러 스레드에서 동시에 하나의 인스턴스에 접근하는 경우가 생길 수 있어 주의해야한다.

- 위와 같은 특성 때문에 TDD(테스트 주도 개발)을 할때 문제가 생기기 쉽다. 테스트 주도 개발을 할때는 테스트가 서로 독립적임과 동시에 테스트를 어떤 순서로든 실행 가능해야하는데, 미리 단 하나의 인스턴스만을 생성하고 이를 전체 프로그램 실행동안 유지하는 싱글톤 패턴에서는 각 테스트마다 독립적인 인스턴스를 생성하기 어렵다.

## 싱글톤의 구현

### 자바

```java
class Singleton {
  private static class SingleInstanceHolder {
    private static final Singleton INSTANCE = new Singleton();
  }
  public static Singleton getInstance() {
    return SingleInstanceHolder.INSTANCE;
  }
}

public class HelloWorld {
  public static void main(String[] args) {
    Singleton a = Singleton.getInstance();
    Singleton b = Singleton.getInstance();
    System.out.println(a.hashcode());
    System.out.println(b.hashcode());
    if (a == b) {
      System.out.println(true)
    }

  }
}
/*
705927765
705927765
true
*/

```

### 자바스크립트

```javascript
const URL = 'mongodb://localhost:27017/myapp'
const createConnection = url => ({url}) // return {"url" : url}

class DB {
  constructor(url) {
    if (!DB.instance) {
      DB.instance = createConnection(url)
    }
    return DB.instance
  }
  connect() {
    return this.instance
  }
}

const a = new DB(URL)
const b = new DB(URL)
console.log(a === b) // true
```

# 2. 팩토리 패턴

## 팩토리 패턴의 정의

객체를 사용하는 코드에서 객체 생성부분을 떼어내 추상화한 패턴이며, 상속관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하면, 하위 클래스에서 객체 새엇ㅇ에 관한 구체적인 내용을 결정하는 패턴이다.

상하위 클래스가 느슨하게 결합되며 상위 클래스는 인스턴스 생성 방식을 신경쓰지 않아도 된다. 객체 생성 로직이 분리되어있어, 코드를 리팩터링해도 한곳만 고칠 수 있게 되어 유지보수가 용이해진다.

## 팩토리 패턴의 장점

- 객체 생성부분을 분리하여, 상위 클래스에서는 하위 클래스의 세부적인 내용을 알지 못해도 인스턴스를 생성하여 사용할 수 있다. 이를 통해 클래스간의 의존성을 낮추고, 결합을 느슨하게 하여 확장을 쉽게 한다.

## 팩토리 패턴의 단점

- 새로 생성할 클래스가 늘어날 수록 클래스 역시 늘어나 복잡성이 증가한다.

# 3. 전략 패턴 (strategy pattern)

## 전략 패턴의 정의

정책 패턴(policy pattern)이라고도 부르며, 객체의 행위를 바꾸고자할 때 직접 수정하지 않고, 전략이라고 부르는 '캡슐화된 알고리즘'을 컨텍스트 안에서 교체할 수 있도록 만드는 패턴이다.

## 전략 패턴의 장점

- 알고리즘을 정의하고 캡슐화하여 알고리즘을 쉽게 변경 및 대체 할 수 있으므로 유연하다

- 알고리즘 추가 및 수정을 했을때 코드의 수정이 최소화되어 확장성이 높아진다.

- 알고리즘을 캡슐화 했으므로로 코드의 재사용성이 높다.

## 전략 패턴의 단점

- 인터페이스 및 클래스가 더욱 늘어나서 코드의 복잡성이 높아진다.

- 실행되는 동안 알고리즘을 선택하여 가져와야하기에 지연시간이 늘어나 성능에 영향을 미친다.

# 4. 옵저버 패턴 (observer pattern)

## 옵저버 패턴의 정의

주체가 어떤 객체의 상태 변화를 관찰하다가 상태변화가 있을때마다 메서드등을 사용, 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴이다. 이러한 객체와 주체는 분리되어있을 수도 있고, 합쳐져 있을 수도 있다.

주체란 객체의 상태변화를 관찰하는 관찰자이고, 옵저버는 이 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 하여 추가적인 변화가 생기는 객체를 뜻한다.


주로 이벤트 기반 시스템 및 MVC(Model - View - Controller) 패턴에도 사용된다.

## 옵저버 패턴의 장점

- 객체의 상태변경을 계속 확인하지 않아도 자동으로 감지하여 옵저버들에게 전파할 수 있다.

- 주체의 코드를 변경하지 않아도 추가적으로 추가적으로 옵저버를 등록하거나 해제할 수 있다.

- 실행 중에도 옵저버를 추가하거나 제거할 수 있다.

- 클래스간의 느슨한 관계를 만들어 서로간의 결합도를 낮추고 의존성을 줄인다.

## 옵저버 패턴의 단점

- 옵저버는 변경을 통지받는 순서를 결정할 수 없다.

- 옵저버 패턴을 자주 사용하면 코드의 구조와 동작을 파악하기 어려워져 복잡성이 증가한다.

- 옵저버를 많이 등록해놓고 해제하지 않는다면 메모리 누수로 이어질 수 있다.

# *의존성 주입

